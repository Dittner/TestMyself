<?xml version="1.0"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009"
         xmlns:s="library://ns.adobe.com/flex/spark"
         xmlns:audio="dittner.testmyself.view.common.audio.*"
         xmlns:editor="dittner.testmyself.view.common.editor.*"
         xmlns:input="dittner.testmyself.view.common.input.*"
         xmlns:list="dittner.testmyself.view.common.list.*"
         xmlns:button="dittner.testmyself.view.common.button.*"
         implements="dittner.testmyself.view.common.editor.IEditor">

    <fx:Script><![CDATA[
        import dittner.testmyself.service.helpers.toolFactory.ToolId;
        import dittner.testmyself.service.helpers.toolFactory.ToolInfo;
        import dittner.testmyself.view.common.utils.AppColors;

        import mx.collections.ArrayCollection;

        //--------------------------------------
        //  themes
        //--------------------------------------
        private var _themes:ArrayCollection;
        [Bindable("themesChanged")]
        public function get themes():ArrayCollection {return _themes;}
        public function set themes(value:ArrayCollection):void {
            if (_themes != value) {
                _themes = value;
                dispatchEvent(new Event("themesChanged"));
            }
        }

        //--------------------------------------
        //  toolInfo
        //--------------------------------------
        private var _toolInfo:ToolInfo;
        [Bindable("toolInfoChanged")]
        public function get toolInfo():ToolInfo {return _toolInfo;}
        public function set toolInfo(value:ToolInfo):void {
            if (_toolInfo != value) {
                _toolInfo = value;
                if (toolInfo.id == ToolId.ADD) setCurrentState("add");
                dispatchEvent(new Event("toolInfoChanged"));
            }
        }

        //--------------------------------------
        //  arrowPos
        //--------------------------------------
        private var _arrowPos:Point;
        [Bindable("arrowPosChanged")]
        public function get arrowPos():Point {return _arrowPos;}
        public function set arrowPos(value:Point):void {
            if (_arrowPos != value) {
                _arrowPos = value;
                dispatchEvent(new Event("arrowPosChanged"));
            }
        }

        private static const HEADER_HEI:uint = EditorBg.HEADER_HEIGHT;
        private static const FOOTER_HEI:uint = 50;
        private static const PAD:uint = 20;
        private static const PAD_TOP:uint = 10;
        private static const HGAP:uint = 10;
        private static const VGAP:uint = 5;
        private static const THEMES_LIST_WID:uint = 250;
        private static const RECORDER_HEI:uint = 72;

        override protected function updateDisplayList(w:Number, h:Number):void {
            super.updateDisplayList(w, h);

            initialArea.x = PAD;
            initialArea.y = HEADER_HEI + PAD_TOP;
            initialArea.height = (h - FOOTER_HEI - HEADER_HEI - PAD - PAD_TOP - 2 * VGAP - RECORDER_HEI) / 2;
            initialArea.width = w - 2 * PAD - HGAP - THEMES_LIST_WID;

            translationArea.x = initialArea.x;
            translationArea.y = initialArea.y + initialArea.height + VGAP;
            translationArea.height = initialArea.height;
            translationArea.width = initialArea.width;

            audioRecorder.x = PAD;
            audioRecorder.y = initialArea.y + 2 * initialArea.height + 2 * VGAP;
            audioRecorder.width = initialArea.width;
            audioRecorder.height = RECORDER_HEI;

            themesList.x = translationArea.x + translationArea.width + HGAP;
            themesList.y = HEADER_HEI + PAD_TOP;
            themesList.height = 2 * initialArea.height + VGAP;

            createThemeInput.x = themesList.x;
            createThemeInput.y = themesList.y + themesList.height + VGAP;
            createThemeInput.width = themesList.width - addBtn.width + 1;

            addBtn.x = createThemeInput.x + createThemeInput.width - 1;
            addBtn.y = createThemeInput.y + 20;

            applyBtn.width = themesList.width;
            applyBtn.right = PAD;
            applyBtn.bottom = (FOOTER_HEI - applyBtn.height + EditorBg.BORDER_THICKNESS) / 2;

            cancelBtn.right = applyBtn.width + applyBtn.right + HGAP;
            cancelBtn.bottom = applyBtn.bottom;
            cancelBtn.width = applyBtn.width;
            cancelBtn.height = applyBtn.height;
        }
        ]]></fx:Script>

    <s:states>
        <s:State name="disabled"/>
        <s:State name="normal"/>
        <s:State name="add"/>
        <s:State name="edit"/>
        <s:State name="remove"/>
    </s:states>


    <editor:EditorBg width="100%" height="100%"
                     title="{toolInfo.description}"
                     arrowPos="{arrowPos}"/>

    <!--ADD EDIT MODE-->


    <input:TextAreaForm id="initialArea"
                        title="Исходный текст"/>

    <input:TextAreaForm id="translationArea"
                        title="Перевод"/>


    <audio:AudioRecordPlayer id="audioRecorder"
                             height="{RECORDER_HEI}"
                             skinClass="dittner.testmyself.view.common.audio.skins.AudioRecordPlayerSkin"/>

    <list:ListForm id="themesList"
                   width="{THEMES_LIST_WID}"
                   dataProvider="{themes}"
                   title="Список тем"
                   itemRenderer="dittner.testmyself.view.common.renderer.ThemeItemRenderer"
                   allowMultipleSelection="true">
        <list:layout>
            <s:VerticalLayout gap="0" useVirtualLayout="false"/>
        </list:layout>
    </list:ListForm>

    <input:TextInputForm id="createThemeInput"
                         title="Название новой темы"/>

    <button:BitmapButton id="addBtn"
                         enabled="{createThemeInput.text != ''}"
                         upImage="@Embed(source='/assets/button/add_element_btn_up.png')"
                         downImage="@Embed(source='/assets/button/add_element_btn_down.png')"/>

    <s:Rect left="{EditorBg.BORDER_THICKNESS}"
            right="{EditorBg.BORDER_THICKNESS}"
            bottom="{EditorBg.BORDER_THICKNESS}"
            height="{FOOTER_HEI}">
        <s:fill>
            <s:SolidColor color="{AppColors.SCREEN_HEADER_BG}"/>
        </s:fill>
    </s:Rect>

    <button:CancelButton id="cancelBtn"
                         label="Отменить"/>

    <button:ApplyButton id="applyBtn"
                        label="Создать"/>


    <!--REMOVE MODE--><!--    <s:VGroup includeIn="remove"
              horizontalCenter="0" top="50" horizontalAlign="center">
        <s:Label color="#ffFFff" fontSize="20" text="Вы действительно хотите безвозвратно удалить текст?"/>
        <s:Label color="#ffFFff" fontSize="30" fontWeight="bold"
                 horizontalCenter="0" top="20" maxWidth="300" maxDisplayedLines="1"
                 text="{hostComponent.collocation.name}"/>
    </s:VGroup>


    <s:HGroup right="20" bottom="10" gap="20">
        <redactor:RedactorButton id="applyBtn"
                                 styleName="applyStyle"
                                 label.add="Добавить" label.edit="Сохранить" label.remove="Удалить" label="Применить"/>
        <redactor:RedactorButton id="cancelBtn" enabled.normal="false" styleName="cancelStyle" label="Отмена"/>
    </s:HGroup>-->


</s:Group>
